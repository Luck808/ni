/**
 * Automation API provider
 * Automation provides template of this description, and anyone may modify it in your own project.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BusinessObjectDTO } from '../model/businessObjectDTO';
import { BusinessObjectPropertyDTO } from '../model/businessObjectPropertyDTO';
import { BusinessPropertyDTO } from '../model/businessPropertyDTO';
import { PageInfoOfBusinessObjectDTO } from '../model/pageInfoOfBusinessObjectDTO';
import { PropertyValidationDTO } from '../model/propertyValidationDTO';
import { PropertyValidationsDTO } from '../model/propertyValidationsDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BusinessObjectService {

    protected basePath = 'https://localhost:10048';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * batchDeleteBusinessObjects
     * batchdeleteBusinessObject
     * @param dtos dtos
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public batchDeleteBusinessObjectsUsingPOST(dtos: Array<BusinessObjectDTO>, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public batchDeleteBusinessObjectsUsingPOST(dtos: Array<BusinessObjectDTO>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public batchDeleteBusinessObjectsUsingPOST(dtos: Array<BusinessObjectDTO>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public batchDeleteBusinessObjectsUsingPOST(dtos: Array<BusinessObjectDTO>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dtos === null || dtos === undefined) {
            throw new Error('Required parameter dtos was null or undefined when calling batchDeleteBusinessObjectsUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<boolean>(`${this.basePath}/xchange/business_object/batchdelete_business_object`,
            dtos,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createBusinessProperty
     * createBusinessProperty
     * @param bp bp
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createBusinessPropertyUsingPOST(bp: BusinessPropertyDTO, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public createBusinessPropertyUsingPOST(bp: BusinessPropertyDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public createBusinessPropertyUsingPOST(bp: BusinessPropertyDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public createBusinessPropertyUsingPOST(bp: BusinessPropertyDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bp === null || bp === undefined) {
            throw new Error('Required parameter bp was null or undefined when calling createBusinessPropertyUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/xchange/business_object/create_business_property`,
            bp,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteBusinessProperty
     * deleteBusinessProperty
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteBusinessPropertyUsingDELETE(id: string, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public deleteBusinessPropertyUsingDELETE(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public deleteBusinessPropertyUsingDELETE(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public deleteBusinessPropertyUsingDELETE(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBusinessPropertyUsingDELETE.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<boolean>(`${this.basePath}/xchange/business_object/delete_business_property`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findBusinessObjectById
     * findBusinessObjectById
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findBusinessObjectByIdUsingGET(id: string, observe?: 'body', reportProgress?: boolean): Observable<BusinessObjectDTO>;
    public findBusinessObjectByIdUsingGET(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BusinessObjectDTO>>;
    public findBusinessObjectByIdUsingGET(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BusinessObjectDTO>>;
    public findBusinessObjectByIdUsingGET(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findBusinessObjectByIdUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BusinessObjectDTO>(`${this.basePath}/xchange/business_object/find_business_object_byid`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * findBusinessProperty
     * findBusinessProperty
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findBusinessPropertyUsingGET(id: string, observe?: 'body', reportProgress?: boolean): Observable<BusinessPropertyDTO>;
    public findBusinessPropertyUsingGET(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BusinessPropertyDTO>>;
    public findBusinessPropertyUsingGET(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BusinessPropertyDTO>>;
    public findBusinessPropertyUsingGET(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findBusinessPropertyUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BusinessPropertyDTO>(`${this.basePath}/xchange/business_object/findone_business_property`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryBusinessObjectByName
     * queryBusinessObjectByName
     * @param name name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryBusinessObjectByNameUsingGET(name: string, observe?: 'body', reportProgress?: boolean): Observable<Array<BusinessObjectDTO>>;
    public queryBusinessObjectByNameUsingGET(name: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BusinessObjectDTO>>>;
    public queryBusinessObjectByNameUsingGET(name: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BusinessObjectDTO>>>;
    public queryBusinessObjectByNameUsingGET(name: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling queryBusinessObjectByNameUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BusinessObjectDTO>>(`${this.basePath}/xchange/business_object/query_businessobject_byname`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryBusinessObjectByParentId
     * queryBusinessObjectByParentId
     * @param parentId parentId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryBusinessObjectByParentIdUsingGET(parentId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<BusinessObjectDTO>>;
    public queryBusinessObjectByParentIdUsingGET(parentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BusinessObjectDTO>>>;
    public queryBusinessObjectByParentIdUsingGET(parentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BusinessObjectDTO>>>;
    public queryBusinessObjectByParentIdUsingGET(parentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (parentId === null || parentId === undefined) {
            throw new Error('Required parameter parentId was null or undefined when calling queryBusinessObjectByParentIdUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (parentId !== undefined && parentId !== null) {
            queryParameters = queryParameters.set('parentId', <any>parentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BusinessObjectDTO>>(`${this.basePath}/xchange/business_object/query_businessobject_byparentid`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryBusinessObject
     * queryBusinessObject
     * @param pageNumber pageNumber
     * @param pageSize pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryBusinessObjectUsingGET(pageNumber: number, pageSize: number, observe?: 'body', reportProgress?: boolean): Observable<PageInfoOfBusinessObjectDTO>;
    public queryBusinessObjectUsingGET(pageNumber: number, pageSize: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageInfoOfBusinessObjectDTO>>;
    public queryBusinessObjectUsingGET(pageNumber: number, pageSize: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageInfoOfBusinessObjectDTO>>;
    public queryBusinessObjectUsingGET(pageNumber: number, pageSize: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageNumber === null || pageNumber === undefined) {
            throw new Error('Required parameter pageNumber was null or undefined when calling queryBusinessObjectUsingGET.');
        }

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryBusinessObjectUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageInfoOfBusinessObjectDTO>(`${this.basePath}/xchange/business_object/findall_business_object`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryBusinessPropertyByObjectIdAndPropertyName
     * queryBusinessPropertyByObjectIdAndPropertyName
     * @param businessObjectId businessObjectId
     * @param propertyName propertyName
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryBusinessPropertyByObjectIdAndPropertyNameUsingGET(businessObjectId: string, propertyName: string, observe?: 'body', reportProgress?: boolean): Observable<Array<BusinessPropertyDTO>>;
    public queryBusinessPropertyByObjectIdAndPropertyNameUsingGET(businessObjectId: string, propertyName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BusinessPropertyDTO>>>;
    public queryBusinessPropertyByObjectIdAndPropertyNameUsingGET(businessObjectId: string, propertyName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BusinessPropertyDTO>>>;
    public queryBusinessPropertyByObjectIdAndPropertyNameUsingGET(businessObjectId: string, propertyName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (businessObjectId === null || businessObjectId === undefined) {
            throw new Error('Required parameter businessObjectId was null or undefined when calling queryBusinessPropertyByObjectIdAndPropertyNameUsingGET.');
        }

        if (propertyName === null || propertyName === undefined) {
            throw new Error('Required parameter propertyName was null or undefined when calling queryBusinessPropertyByObjectIdAndPropertyNameUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (businessObjectId !== undefined && businessObjectId !== null) {
            queryParameters = queryParameters.set('businessObjectId', <any>businessObjectId);
        }
        if (propertyName !== undefined && propertyName !== null) {
            queryParameters = queryParameters.set('propertyName', <any>propertyName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BusinessPropertyDTO>>(`${this.basePath}/xchange/business_object/query_businessproperty_byobjectid_and_propertyname`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryBusinessProperty
     * queryBusinessProperty
     * @param businessObjectId businessObjectId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryBusinessPropertyUsingGET(businessObjectId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<BusinessPropertyDTO>>;
    public queryBusinessPropertyUsingGET(businessObjectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BusinessPropertyDTO>>>;
    public queryBusinessPropertyUsingGET(businessObjectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BusinessPropertyDTO>>>;
    public queryBusinessPropertyUsingGET(businessObjectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (businessObjectId === null || businessObjectId === undefined) {
            throw new Error('Required parameter businessObjectId was null or undefined when calling queryBusinessPropertyUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (businessObjectId !== undefined && businessObjectId !== null) {
            queryParameters = queryParameters.set('businessObjectId', <any>businessObjectId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BusinessPropertyDTO>>(`${this.basePath}/xchange/business_object/findall_business_property`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * queryValidation
     * query_Validation
     * @param propertyId propertyId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public queryValidationUsingGET(propertyId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PropertyValidationDTO>>;
    public queryValidationUsingGET(propertyId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PropertyValidationDTO>>>;
    public queryValidationUsingGET(propertyId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PropertyValidationDTO>>>;
    public queryValidationUsingGET(propertyId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling queryValidationUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (propertyId !== undefined && propertyId !== null) {
            queryParameters = queryParameters.set('propertyId', <any>propertyId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PropertyValidationDTO>>(`${this.basePath}/xchange/business_object/query_Validation`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * saveBusinessObjectProperty
     * saveBusinessObjectProperty
     * @param bop bop
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveBusinessObjectPropertyUsingPOST(bop: BusinessObjectPropertyDTO, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public saveBusinessObjectPropertyUsingPOST(bop: BusinessObjectPropertyDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public saveBusinessObjectPropertyUsingPOST(bop: BusinessObjectPropertyDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public saveBusinessObjectPropertyUsingPOST(bop: BusinessObjectPropertyDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bop === null || bop === undefined) {
            throw new Error('Required parameter bop was null or undefined when calling saveBusinessObjectPropertyUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/xchange/business_object/save_businessobject_property`,
            bop,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * saveValidation
     * save_Validation
     * @param pvs pvs
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public saveValidationUsingPOST(pvs: PropertyValidationsDTO, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public saveValidationUsingPOST(pvs: PropertyValidationsDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public saveValidationUsingPOST(pvs: PropertyValidationsDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public saveValidationUsingPOST(pvs: PropertyValidationsDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pvs === null || pvs === undefined) {
            throw new Error('Required parameter pvs was null or undefined when calling saveValidationUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/xchange/business_object/save_Validation`,
            pvs,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateBusinessProperty
     * updateBusinessProperty
     * @param bp bp
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateBusinessPropertyUsingPUT(bp: BusinessPropertyDTO, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public updateBusinessPropertyUsingPUT(bp: BusinessPropertyDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public updateBusinessPropertyUsingPUT(bp: BusinessPropertyDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public updateBusinessPropertyUsingPUT(bp: BusinessPropertyDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bp === null || bp === undefined) {
            throw new Error('Required parameter bp was null or undefined when calling updateBusinessPropertyUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<number>(`${this.basePath}/xchange/business_object/update_business_property`,
            bp,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
